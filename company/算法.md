# 算法

## 动态规划

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

<img src="./算法_images/image-20251011175745498.png" alt="image-20251011175745498" style="zoom:50%;" /> 

```java
public int rob(int[] nums) {
      if (nums.length == 1)
          return nums[0];

      //定义dp：偷走前i个房间的最大值
      int dp[] = new int[nums.length];

      //偷前面1个房间，本身就最大
      dp[0] = nums[0];
      //偷前2个,看第1个和第2个谁最大，因为不能连续偷
      dp[1] = Math.max(nums[1], nums[0]);
		
  		//转移方程:从第3个开始偷
      for (int i = 2; i < nums.length; i++) {
          //判断是自己的价值+前面隔1个的大，还是前1个的大
          dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
      }

      return dp[nums.length - 1];
}
```













### 不同路径1️⃣

> https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html

<img src="./算法_images/image-20250827153546434.png" alt="image-20250827153546434" style="zoom:50%;" /> 

```java
//        dp[0][0] = 1;
//        dp[0][1] = dp[0][0];
//        dp[1][0] = dp[0][0];
//        dp[0][2] = dp[0][1]= dp[0][0];

//        dp[1][2] = dp[1][1] + dp[0][2];  //2+1=3  我可以从11过来，也可以从02过来
//        dp[2][1] = dp[2][0] + dp[1][1];  //1+2=3  我可以从20过来，也可以从11过来
//
//        dp[1][1] = dp[1][0] + dp[0][1];   //2			我可以从10过来，也可以从01过来
//        dp[2][2] = dp[2][1] + dp[1][2];  //3+3=6  我可以从21过来，也可以从12过来
//        dp[3][3] = dp[3][2] + dp[2][3];

public int uniquePaths(int m, int n) {
        //dp：机器人到m行n列有几种方式
        int[][] dp = new int[m][n];
       //初始化自己到自己只有一种方式（符合测试用例）
        dp[0][0] = 1;
  
       //初始化往下走i行都只有一种方式
        for (int i = 1; i < m; i++) {
            dp[i][0] = 1;
        }
  		 //初始化往右走i列都只有一种方式
        for (int i = 1; i < n; i++) {
            dp[0][i] = 1;
        }

   		 //转移方程
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }
        return dp[m-1][n-1];
    }
```







### 不同路径2️⃣

> https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

<img src="./算法_images/image-20250827153508089.png" alt="image-20250827153508089" style="zoom:67%;" />

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
  
        //dp：机器人到m行n列有几种方式
        int[][] dp = new int[m][n];

        //如果只有一行，里面只要有障碍就直接返回0
        if (m == 1) {
            for (int i = 0; i < n; i++) {
                if (obstacleGrid[0][i] == 1) {
                    return 0;
                }
            }
        }

        //左上角的robot如果是障碍，那么直接返回0
        if (obstacleGrid[0][0] != 1) {
            dp[0][0] = 1;
        } else {
            dp[0][0] = 0;
            return dp[0][0];
        }
  
        //初始化外层下边路:
        for (int i = 1; i < m; i++) {
            // 如果下面边路只要有1个0，那么它的下边边路全部过不去了，全是0
            if (obstacleGrid[i][0] == 1)
                break;
            dp[i][0] = 1;
        }
       //初始化外层右边路:
        for (int i = 1; i < n; i++) {
            // 如果右边边路只要有1个0，那么它的右边所有全部过不去了，全是0
            if (obstacleGrid[0][i] == 1)
                break;
            dp[0][i] = 1;
        }

  			//转移方程
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                //如果不是障碍,那么就等于左边和上边的路径总和
                if (obstacleGrid[i][j] != 1) {
                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
                }
            }
        }

        return dp[m - 1][n - 1];
    }
```



### 分隔等和子集

> **这道题本质还是将指定物品放进容量为所有元素总和一半的背包中，怎么装才能让它的价值正好等于元素总和的一半**

<img src="./算法_images/image-20250827154355861.png" alt="image-20250827154355861" style="zoom:50%;" /> 

```java
//[1，5，5，11]
//       0 1 2 3 4 5 6 7 8 9 10 11
// 1（1） 0 1 1 1 1 1 1 1 1 1 1  1
// 2（5） 0 1 1 1 1 5 6 6 6 6 6  6
// 3（5） 0 1 1 1 1 5 6 6 6 6 6  6
// 4（11）0 1 1 1 1 5 6 6 6 6 6  11

//[3,3,3,4,5]
/**         0 1 2 3 4 5 6 7 8 9
 * 商品   3 0 0 0 3 3  3 3 3 3 3
 *       3 0 0 0 3 3  3 6 6 6 6
 *       3 0 0 0 3 3  3 6 6 6 9
 *       4 0 0 0 3 4  4 6 7 7 9
 *       5 0 0 0 3 4  5 6 7 8 9
 */

public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        //如果是奇数,说明不能平分
        if (sum % 2 != 0)
            return false;

        //nums本身类似于价值和重量
        //nums:[1,2,5]
        //nums的数量类似于物品数量
        int goodsSize = nums.length;
        //类似于背包重量
        int weight = sum / 2;

        //定义dp为任取商品数量在0～重量下的最大价值(此时的最大价值必须是2/sum)
        int dp[][] = new int[goodsSize][weight + 1];
        dp[0][0] = 0;
        //如果背包容量是0,价值也是0
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = 0;
        }
        //初始化价值
        for (int i = 1; i < dp[0].length; i++) {
            //如果第一个商品的重量小于背包重量的话，那么就默认变为0
            if (i < nums[0]) {
                dp[0][i] = 0;
            } else {
                //否则就是自己的重量
                dp[0][i] = nums[0];
            }
        }

        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                //当前的背包容量<自身重量，就用上一行的
                if (j < nums[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                  //否则说明背包容量够
                    dp[i][j] = Integer.max(dp[i - 1][j], nums[i] + dp[i - 1][j - nums[i]]);
                }
            }
        }

        return dp[goodsSize - 1][weight] == weight ? true : false;
    }
```

