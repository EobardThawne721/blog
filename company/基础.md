# 基础

## Java的参数传递

> **Java永远都是`值传递`，永远是把实参的值拷贝一份传给形参**

* 传基本类型：传的就是值本身，拷贝一份给形参，形参改动不会影响原对象

* **传引用类型：传的就是本身对象的值地址（内存地址），拷贝一份内存地址给形参，两者指向的都是同一个地方，所以修改会有影响**

  * **如果形参内部又重新new了一次，那么指向的就是不同的地址，形参改动不会影响原对象**

  ```java
  public static void show(StringBuffer a) { //首先拷贝sb的内存值地址给a，指向同一个地方
      a = new StringBuffer("world");//a指向新地址，sb的地址还是旧地址，两者指向不一样
  }
  
  StringBuffer sb=new StringBuffer("hello");
  System.out.println("pre:"+sb);
  show(sb);
  System.out.println("next:"+sb);
  //pre:hello
  //next:hello
  ```

  



## 数据类型

> **Java分为基本数据类型和引用数据类型**

* 基本数据类型：

  * boolean：1位；取值范围：true～false

  * byte：1个字节，8位；取值范围：-128～127

  * char：2个字节，16位；取值范围：0～65535（因为是字符，所以不会有负数）

  * short：2个字节，16位；取值范围：-32768～32767

  * int：4个字节，32位；取值范围：-2^31^ ~ 2^31^-1

  * long：8个字节，64位；取值范围：-2^63^ ~ 2^63^-1

  * float：4个字节，32位；取值范围：单精度浮点数，有效位数约 6 - 7 位

  * double：8个字节，64位；取值范围：双精度浮点数，有效位数约 15 位

    > **byte、char、short参与运算会自动转为int类型，boolean不参与类型转换；表达式运算会自动提升为操作数据中最大的类型**

* 引用数据类型：

  * 类、接口

  * 数组

  * 集合等等

    > **对对象的引用，存储的是对象在内存中的地址**



## 装箱拆箱

* 自动装箱：编译器自动将基本数据类型转换为对应的包装类型

  ```java
  List<Integer> list = new ArrayList<>();
  list.add(1);  	// int 自动装箱为 Integer
  ```

* 自动拆箱：编译器自动将包装类型转换为对应的基本数据类型

  ```java
  void bar(int y) { ... }
  bar(new Integer(30));  // 自动拆箱为 int
  
  Integer i = null;
  int x = i;  // ❌ NullPointerException，因为要拆箱
  ```

  > 若引用类型为空，拆箱转为基本类型时会NPE





## ==和equals

* ==：对于基本类型，比较的是它们的值；对于对象时，比较的是内存地址，是否指向同一个实例
* equals：属于Object类中方法，默认比较内存地址；但许多类（如String、Integer等）重写了此方法，提供基于内容的比较



## 修饰符范围

* public：任何范围都能访问
* private：只在当前类可访问
* protected：同一个包下可以访问、不同包中的子类可访问（通过继承来的）
* 无修饰符：同一个包下可以访问（包级私有）





## final关键字

> **final关键字可以用来修饰类、方法、变量**

* 修饰类：被final修饰的类可以被实例化但不能被继承（eg：String、System），可以继承非final类。
  * 设计意图：保证类的不可变性和安全性（如String类防止子类破坏字符串内容、System类防止核心API被篡改）

* 修饰方法：被final修饰的方法不能被子类重写，但可以被子类继承使用；不能修饰构造方法、抽象方法、接口方法

  * 设计意图：防止核心逻辑被修改

* 修饰变量：被final修饰的变量为常量，不能被更改

  * 修饰成员变量：可在定义时初始化值、构造方法中初始化值、代码块中初始化值

  * 修饰静态常量：可在定义时初始化值、静态代码块中初始化值

  * 修饰局部变量：如果未被使用，可以不赋值，如果使用了必须赋值

  * 修饰形参变量：如果是基本类型数据，则只能被访问，不能被修改值；如果是包装类型则可以修改内容，不能被重新赋值

    ```java
    public void test(final int x, final List<String> list) {
        // x = 10; 										// ❌ 不允许
        // list = new ArrayList<>();  // ❌ 不允许重新赋值
      	list.add("A"); 								// ✅ 允许修改对象的内容
    }
    ```

    

## String类为什么是不可变的

* 类声明是final类型，不能被继承修改；内部没有提供修改内容的地方；存储内容的地方是`private final byte[] value`，只能被赋值一次，不能被修改

* 对String进行修改时，都会创建一个新的对象，而原有的字符串对象保持不变

* 线程安全，因为值不能被修改，多个线程共享同一个String对象，同时也保证了数据的安全性

* 优化常量池性能，当创建多个相同内容的String时，JVM会使用同一个对象而不会创建新的

  ```java
  String s1="ZO_OM";
  String s2="ZO_OM";
  s1==s2;	//true
  
  String s1="hello";
  String s2="world";
  String s3="hello world";//编译时放进常量池的
  String s4=s1+" "+s2;		//运行期拼接
  s3==s4;//false 
  ```

* hashCode缓存优化，第一次计算时会被缓存下来，由于String不可变的特点，相同的字符串内容、引用或哈希key都会复用存在的hashCode

  ```java
  String s1="ZO_OM";
  String s2="ZO_OM";
  int i1 = s1.hashCode();//85564200
  int i2 = s1.hashCode(); //85564200
  int i3 = s2.hashCode();//85564200
  ```

* 性能考虑，频繁修改字符串的时候都会创建新的对象，为了优化性能，可以使用可变的StringBuilder、StringBuffer



## String 、StringBuffer、String Builder的区别

| 类            | 是否可变                       | 线程安全性                                 | 性能     | 适用场景                             |
| ------------- | ------------------------------ | ------------------------------------------ | -------- | ------------------------------------ |
| String        | 不可变，final byte[] value存值 | **线程安全，共享同一个对象**               | 性能较低 | 字符串不变时，常量池等使用           |
| StringBuffer  | 可变，byte[] value存值         | **线程安全，内部方法用synchronized锁修饰** | 性能较低 | **多线程环境**下需要修改字符串时使用 |
| StringBuilder | 可变，byte[] value;存值        | **不安全**                                 | 性能较高 | **单线程环境**下频繁修改字符串时使用 |



## 静态变量与实例变量

* 实例范围：静态变量在类加载就只实例一次，所有对象共享一份数据（改一个，全部都受影响）；实例变量每个对象都有自己独立一份（每个对象互不影响，改一个不会影响其它对象）
* 内存位置：静态变量在方法区的静态存储区；实例变量在堆内存中，随对象创建而存在
* 生命周期：静态变量类加载时创建，销毁时销毁；实例变量在对象创建时存在，回收时销毁
* 访问方式：静态变量可通过类名或对象名调用；实例变量只能通过对象名访问

> **静态方法只能访问静态变量、调用静态方法，无法访问实例变量或实例方法**



## 异常处理机制

* 编写可能出现异常的代码时，可放入try代码块中
* try后可以有一个或多个catch块来捕捉，catch中子类异常顺序在父类异常前（eg：先捕获ClassCastException，再捕获Exception）
* 可选地加入finally块执行清理代码
* 方法声明时使用throws 抛出；方法体使用throw new 抛出





# 面向对象

## 方法重载与方法覆盖

> 多态包含了方法重载与方法覆盖

* 方法重载：

  * 同一个类中多个方法名相同，参数不同
  * 返回类型可以不同，但不作为重载的依据

* 方法覆盖：

  * 子类重写父类的方法，方法名相同，参数相同

  * 返回类型必须相同、返回子类类型（减少类型转换）

    ```java
    public abstract class UTjfjxvg3 {
        public abstract UTjfjxvg3 show();
    }
    
    public  class UTmmag extends UTjfjxvg3 {
        @Override
        public UTmmag show() {
            return null;
        }
    }
    ```

    

## 抽象类与接口

> **抽象类通常是作为子类的基类，`描述的是子类共有的属性和行为，但某些行为需要子类去实现`；接口通常是描述一组类共同遵循的某种行为规范，`但它们本身可能不存在继承关系`**

* 成员变量：抽象类可以有任何修饰符的变量；接口必须且默认是public static final的常量，且定义时必须初始化
* 成员方法：抽象类有抽象方法和普通方法，抽象方法不能用private、static、final修饰；接口默认抽象方法，Java8后可以有默认方法、静态方法、私有方法
* 构造方法：抽象类可以有构造方法；接口不允许
* 实例化：两者都不能被实例化
* 继承关系：抽象类单继承；接口多实现
* **选择性：抽象类可以作为模版方法，定义了类的骨架；接口更倾向于添加新功能或兼容性问题，不适合作为骨架**





# IO流

> **所有数据读写操作在Java中都抽象为流，输入流：从数据源读取到程序中(内存中)；输出流：把数据从程序(内存)写出到目标**

* 字节流：以1个字节为单位传输数据，适合处理二进制数据，如图片、音视频
* 字符流：以字符(16位Unicode)为单位传输数据，适合处理文本数据





## 为什么需要缓冲流

* 不管是字节流还是字符流，每次读写时，都会直接和底层设备（文件、磁盘、网络）交互，但是磁盘和网络IO非常慢，如果一次只读写几个字节就会频繁调用，性能很差
  * eg：读取8192个字符，字符流需要8192次，缓冲流假设为1024的大小，需要8次
* **缓冲流在内存中维护了一个缓冲区（byte[ ] ）**
  * **读操作：一次性从底层设备读取一大块数据放到缓冲区，再从缓冲区返回给用户程序，避免了程序的磁盘读取。**
  * **写操作：先将数据写入到缓冲区，等缓冲区满了或手动flush()时，再一次性写入到底层设备，减少了系统调用次数**

> 在处理字符数据时，**BufferedReader**通常比**BufferedInputStream**更快，因为它专为字符流优化，减少了不必要的数据转换开销；在处理字节数据时，BufferedInputStream更为合适和高效。





## IO模型

* BIO（Blocking IO，阻塞IO）：读取或写入数据时，线程会一直等待（eg：Java的传统IO操作），直到数据准备就绪或写入完成，但在高并发下存在性能问题（因为线程会等待IO操作时阻塞，无法执行其它任务）
* NIO（Non- Blocking IO，非阻塞IO）：线程执行一个IO时不会一直等待，而是继续执行其它任务，需要通过轮询或者回调函数等机制检查IO操作是否完成，能更好的支持并发，但会导致CPU资源浪费（因为会不停的调用判断数据处理好了没）
* AIO（Asynchronous IO，异步IO）：线程执行IO时允许执行其它任务，不需要等待IO操作完成，操作系统完成后会自动通过回调通知，不需要轮询
* IO多路复用：使用操作系统Selector机制（eg：Java的Selector类），通过选择器，一个线程可以监听多个通道上的IO事件，从而在单线程中处理多个连接（socket）



## 序列化与反序列化

* 序列化：把Java对象转为字节的过程，这些字节序列可以保存在磁盘上、网络中传输，并允许程序将这些字节序列再次恢复成原来的对象
* 反序列化：把字节序列还原成 Java 对象的过程



注意：

1. 其中需要序列化的对象需要实现Serializable接口
2. `transient` 修饰的字段不会被序列化
3. **`serialVersionUID` 很重要**，类修改后如果 ID 不匹配，反序列化会失败
   * 如果该对象类没有指定默认的版本号，JVM会根据类结构自动生成版本号，当类的结构改变时，版本号也会变化，当旧的序列化数据反序列化时会报错，因为两者的版本号已经变化
   * 如果该对象类指定了默认的版本号，那么旧的序列化数据反序列化时，会认为版本兼容，新增字段在旧序列化数据会变成对应类型的默认值



# 集合

## Vector和ArrayList区别

* 两者都是动态数组结构
* 线程安全和效率：ArrayList非线程安全，效率更高；Vector线程安全，效率低，所有的方法都用synchronized同步锁
* 扩容机制：ArrayList默认扩容为原来的1.5倍；Vector扩容为原来的两倍





## HashSet是如何保证元素不重复的？

* 基于哈希表实现

  HashSet构造函数中是通过HashMap来存储元素，其中Key为本身新增的元素，Value为HashSet为内部固定的静态Object对象(私有Present)

  ```java
  private transient HashMap<E,Object> map;
  private static final Object PRESENT = new Object();
  
  public HashSet() {
      map = new HashMap<>();
  }
  
  public boolean add(E e) {
    	return map.put(e, PRESENT)==null;
  }
  ```

* 使用hashCode和equals方法

  * 当向HashSet添加一个元素的时候，首先调用hashCode方法计算哈希值来决定在哈希表中的存储位置
  * 在确定存储位置后，HashSet会检查该位置是否存在相同哈希值的元素，如果存在，利用equals方法判断两个元素是否相等，如果相同，认为元素存在，不能添加；否则添加到哈希表中
  * 通过以上两个方法，HashSet可以快速检测和防止重复元素的添加，确保每个元素在Set中唯一的，HashSet 本质就是“只有 Key 的 HashMap”



## HashSet和HashMap的区别

> 如果需要存储一堆不重复的东西，用 `HashSet`；如果需要给这些东西关联额外的信息，用 `HashMap`。

* HashSet存储的不重复的单个元素，用于快速检查某个元素key是否存在；HashMap存储k-v对

* HashSet基于HashMap，当HashSet添加相同key时会判断是否存在旧value，存在就直接失败；HashMap则会覆盖旧value

  ```java
  //省略HashSet其它代码
  public boolean add(E e) {
    	return map.put(e, PRESENT)==null;
  }
  ```

  





## List接口和Set接口区别

* 元素重复：List接口允许元素重复，Set接口不允许元素重复
* 元素插入顺序：List接口元素按照插入顺序排列，有固定位置；Set接口大部分实现类是无序的
* 元素位置访问：List接口提供了访问元素的方法，如get；Set接口没有提供这样的方法



## HashMap的put方法返回值

> **`HashMap.put()` 返回的是旧值，如果没有旧值（首次插入），返回 null**

```java
HashMap<String, String> map = new HashMap<>();
System.out.println(map.put("a", "1")); // null，因为 "a" 第一次插入
System.out.println(map.put("a", "2")); // 1，返回旧值 "1"
System.out.println(map.put("a", "3")); // 2，返回旧值 "2"
```





## HashMap和TreeMap的区别

* 底层结构：HashMap基于哈希表实现的，通过hash值确定存储位置；TreeMap基于红黑树实现的，是一种**自平衡二叉查找树**
* key值顺序：HashMap默认情况下，不保证元素的存储顺序；TreeMap能够保证key的有序性，总是按照key的自然顺序创建或者自定义Comparator进行排序
* key为null：**HashMap最多允许1个null key和多个null value**（所有null key会被映射到数组下标0的位置，并且会覆盖之前的null key）；**TreeMap 不允许 null key，允许 null value**（因为是拿key作为树节点，BST树节点为空就不能查找了）
* 复杂度：HashMap的查找、插入、删除平均复杂度为O(1)；TreeMap的查找、插入、删除的时间复杂度为O(logn)





## HashMap和HashTable的区别

* 底层结构：HashMap为数组+链表和红黑树；HashTable是数组+链表

* **效率：HashMap效率高，因为没有锁开销；HashTable大部分方法有synchronized同步锁**

* 线程安全：HashMap非线程安全（如果需要线程安全，推荐使用`ConcurrentHashMap`）；HashTable线程安全

* 扩容机制：HashMap默认16，扩容x2；HashTable默认11，扩容x2+1

* **null值：HashMap允许一个null key和多个null value；HashTable不允许null key和value**

  ```java
  //省略HashTable其它代码
  public synchronized V put(K key, V value) {
          if (value == null) {
              throw new NullPointerException();
          }
          int hash = key.hashCode(); //如果key为空，这里也会空指针
   }
  ```

  



# Spring

## Spring使用到的设计模式

* 工厂设计模式：Spring使用工厂模式通过BeanFactory、ApplicationContext 创建 bean 对象。
* 代理设计模式：Spring AOP功能实现（JDK动态代理、CGLIB动态代理）
* 单例设计模式：Spring 中的 Bean 默认都是单例的、并且是饿汉式模式(启动容器就生成实例，懒汉式：第一次请求才会创建)
* 模版方法设计模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作
* 适配器模式：Spring AOP 的增强或通知、Spring MVC都用到了适配器模式





## AOP

> **AOP在spring中有两种实现方式：JDK动态代理、CGLIB动态代理**

* JDK动态代理（默认情况，eg：常用开发中service、service.impl）：目标类实现了某个接口，运行时生成代理类实现接口的方法
* CGLIB动态代理（eg：没有父类、接口就会切换为CGLIB或者强制配置Spring使用）：目标类和方法不能声明为final（因为是通过继承的方式，所以不能是final），运行时为目标类生成一个子类，覆盖其中的所有方法



## @Autowired和@Resource区别

* @Autowired是Spring提供的注解；@Resource是JDK提供的注解
* @Autowired是只能按类型注入；@Resource先按名次注入，找不到再按类型注入
* @Autowired可以和@Qualifier一起使用按名次注入；@Resource可以配置name属性或type属性来指定方式注入





## BeanFactory接口和FactoryBean接口区别

> **BeanFactory（Bean工厂） 是 Spring 的工厂，FactoryBean（工厂Bean）是自定义功能的特殊Bean**

*  **BeanFactory是Spring最核心的IOC接口，用来管理Bean的生命周期，提供getBean()等方法**
  * **BeanFactory**和**ApplicationContext**是**spring**框架的两个**IOC**容器，现在一般使用 **ApplicationnContext**（eg：最常见的子类ClassPathXmlApplicationContext类路径加载xml、AnnotationConfigApplicationContext注解加载等，都是**ApplicationContext**的子类，而ApplicationContext间接实现了BeanFactory）
* **FactoryBean是Spring提供的特殊接口，用来定制Bean的创建逻辑**（eg：返回代理对象、复杂对象、第三方类）
  * 某些特殊情况下，实例化Bean需要复杂逻辑，如果按照传统xml方式则会配置大量信息，此时就可以实现这个接口来定制化



## 事务传播机制

> 前提条件：**在一个事务方法中调用了另一个事务方法**，也就是“外层事务包含了内层事务的执行”，eg：事务A代码块里面调用了事务B的代码块方法

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;

    @Transactional(propagation = Propagation.REQUIRED） //设置级别，默认REQUIRED
    public void methodA() {
        System.out.println("A start");
        serviceB.methodB();		//事务A钟包含事务B
        System.out.println("A end");
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.xxx） //自定义设置级别，下面任意几个之一
    public void methodB() {
        System.out.println("B running");
        throw new RuntimeException("B出错了");
    }
}
```

==注意：下面说的外层内层事务，默认将外层设为REQUIRED级别，内层自定义设为下面几种之一，方便理解==

* REQUIRED（默认）：如果外层存在事务，内层则加入当前事务；如果外层没有事务，则内层方法会新建一个事务（**eg：A和B要么同时提交，要么同时回滚）**

* REQUIRES_NEW：**内层总是新建一个事务，保证自己独立提交或回滚**，原来的外层事务挂起**（eg：B回滚，A不受影响）**

* NESTED：如果外层有事务，内层事务会在外层嵌套一个事务保存点，如果内层回滚不会影响外层；如果没有事务，则新建一个事务（**内层事务依赖外层事务，属于外层事务的嵌套保存点**）

* SUPPORTS：如果外层有事务，内层则加入当前事务；如果外层没有事务，内层不管有无事务都是以普通方法执行

* NOT_SUPPORTED：如果外层有事务，就把外层事务挂起，内层当成普通方法处理（**内层出现异常也不会回滚，但是内层抛出异常会影响外层事务）**

* NEVER：不支持事务，如果存在事务，就抛异常（**只要内层处于外层事务中就抛异常**）

* MANDATORY：必须运行在事务中，没事务就抛异常（**只要外层没事务就抛异常**）

  















































