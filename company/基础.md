# 基础

## Java的参数传递

> **Java永远都是`值传递`，永远是把实参的值拷贝一份传给形参**

* 传基本类型：传的就是值本身，拷贝一份给形参，形参改动不会影响原对象

* **传引用类型：传的就是本身对象的值地址（内存地址），拷贝一份内存地址给形参，两者指向的都是同一个地方，所以修改会有影响**

  * **如果形参内部又重新new了一次，那么指向的就是不同的地址，形参改动不会影响原对象**

  ```java
  public static void show(StringBuffer a) { //首先拷贝sb的内存值地址给a，指向同一个地方
      a = new StringBuffer("world");//a指向新地址，sb的地址还是旧地址，两者指向不一样
  }
  
  StringBuffer sb=new StringBuffer("hello");
  System.out.println("pre:"+sb);
  show(sb);
  System.out.println("next:"+sb);
  //pre:hello
  //next:hello
  ```

  



## 数据类型

> **Java分为基本数据类型和引用数据类型**

* 基本数据类型：

  * boolean：1位；取值范围：true～false

  * byte：1个字节，8位；取值范围：-128～127

  * char：2个字节，16位；取值范围：0～65535（因为是字符，所以不会有负数）

  * short：2个字节，16位；取值范围：-32768～32767

  * int：4个字节，32位；取值范围：-2^31^ ~ 2^31^-1

  * long：8个字节，64位；取值范围：-2^63^ ~ 2^63^-1

  * float：4个字节，32位；取值范围：单精度浮点数，有效位数约 6 - 7 位

  * double：8个字节，64位；取值范围：双精度浮点数，有效位数约 15 位

    > **byte、char、short参与运算会自动转为int类型，boolean不参与类型转换；表达式运算会自动提升为操作数据中最大的类型**

* 引用数据类型：

  * 类、接口

  * 数组

  * 集合等等

    > **对对象的引用，存储的是对象在内存中的地址**



## 装箱拆箱

* 自动装箱：编译器自动将基本数据类型转换为对应的包装类型

  ```java
  List<Integer> list = new ArrayList<>();
  list.add(1);  	// int 自动装箱为 Integer
  ```

* 自动拆箱：编译器自动将包装类型转换为对应的基本数据类型

  ```java
  void bar(int y) { ... }
  bar(new Integer(30));  // 自动拆箱为 int
  
  Integer i = null;
  int x = i;  // ❌ NullPointerException，因为要拆箱
  ```

  > 若引用类型为空，拆箱转为基本类型时会NPE





## ==和equals

* ==：对于基本类型，比较的是它们的值；对于对象时，比较的是内存地址，是否指向同一个实例
* equals：属于Object类中方法，默认比较内存地址；但许多类（如String、Integer等）重写了此方法，提供基于内容的比较



## 修饰符范围

* public：任何范围都能访问
* private：只在当前类可访问
* protected：同一个包下可以访问、不同包中的子类可访问（通过继承来的）
* 无修饰符：同一个包下可以访问（包级私有）





## final关键字

> **final关键字可以用来修饰类、方法、变量**

* 修饰类：被final修饰的类可以被实例化但不能被继承（eg：String、System），可以继承非final类。
  * 设计意图：保证类的不可变性和安全性（如String类防止子类破坏字符串内容、System类防止核心API被篡改）

* 修饰方法：被final修饰的方法不能被子类重写，但可以被子类继承使用；不能修饰构造方法、抽象方法、接口方法

  * 设计意图：防止核心逻辑被修改

* 修饰变量：被final修饰的变量为常量，不能被更改

  * 修饰成员变量：可在定义时初始化值、构造方法中初始化值、代码块中初始化值

  * 修饰静态常量：可在定义时初始化值、静态代码块中初始化值

  * 修饰局部变量：如果未被使用，可以不赋值，如果使用了必须赋值

  * 修饰形参变量：如果是基本类型数据，则只能被访问，不能被修改值；如果是包装类型则可以修改内容，不能被重新赋值

    ```java
    public void test(final int x, final List<String> list) {
        // x = 10; 										// ❌ 不允许
        // list = new ArrayList<>();  // ❌ 不允许重新赋值
      	list.add("A"); 								// ✅ 允许修改对象的内容
    }
    ```

    

## String类为什么是不可变的

* 类声明是final类型，不能被继承修改；内部没有提供修改内容的地方；存储内容的地方是`private final byte[] value`，只能被赋值一次，不能被修改

* 对String进行修改时，都会创建一个新的对象，而原有的字符串对象保持不变

* 线程安全，因为值不能被修改，多个线程共享同一个String对象，同时也保证了数据的安全性

* 优化常量池性能，当创建多个相同内容的String时，JVM会使用同一个对象而不会创建新的

  ```java
  String s1="ZO_OM";
  String s2="ZO_OM";
  s1==s2;	//true
  
  String s1="hello";
  String s2="world";
  String s3="hello world";//编译时放进常量池的
  String s4=s1+" "+s2;		//运行期拼接
  s3==s4;//false 
  ```

* hashCode缓存优化，第一次计算时会被缓存下来，由于String不可变的特点，相同的字符串内容、引用或哈希key都会复用存在的hashCode

  ```java
  String s1="ZO_OM";
  String s2="ZO_OM";
  int i1 = s1.hashCode();//85564200
  int i2 = s1.hashCode(); //85564200
  int i3 = s2.hashCode();//85564200
  ```

* 性能考虑，频繁修改字符串的时候都会创建新的对象，为了优化性能，可以使用可变的StringBuilder、StringBuffer



## String 、StringBuffer、String Builder的区别

| 类            | 是否可变                       | 线程安全性                                 | 性能     | 适用场景                             |
| ------------- | ------------------------------ | ------------------------------------------ | -------- | ------------------------------------ |
| String        | 不可变，final byte[] value存值 | **线程安全，共享同一个对象**               | 性能较低 | 字符串不变时，常量池等使用           |
| StringBuffer  | 可变，byte[] value存值         | **线程安全，内部方法用synchronized锁修饰** | 性能较低 | **多线程环境**下需要修改字符串时使用 |
| StringBuilder | 可变，byte[] value;存值        | **不安全**                                 | 性能较高 | **单线程环境**下频繁修改字符串时使用 |



## 静态变量与实例变量

* 实例范围：静态变量在类加载就只实例一次，所有对象共享一份数据（改一个，全部都受影响）；实例变量每个对象都有自己独立一份（每个对象互不影响，改一个不会影响其它对象）
* 内存位置：静态变量在方法区的静态存储区；实例变量在堆内存中，随对象创建而存在
* 生命周期：静态变量类加载时创建，销毁时销毁；实例变量在对象创建时存在，回收时销毁
* 访问方式：静态变量可通过类名或对象名调用；实例变量只能通过对象名访问

> **静态方法只能访问静态变量、调用静态方法，无法访问实例变量或实例方法**



## 异常处理机制

* 编写可能出现异常的代码时，可放入try代码块中
* try后可以有一个或多个catch块来捕捉，catch中子类异常顺序在父类异常前（eg：先捕获ClassCastException，再捕获Exception）
* 可选地加入finally块执行清理代码
* 方法声明时使用throws 抛出；方法体使用throw new 抛出





# 面向对象

## 方法重载与方法覆盖

> 多态包含了方法重载与方法覆盖

* 方法重载：

  * 同一个类中多个方法名相同，参数不同
  * 返回类型可以不同，但不作为重载的依据

* 方法覆盖：

  * 子类重写父类的方法，方法名相同，参数相同

  * 返回类型必须相同、返回子类类型（减少类型转换）

    ```java
    public abstract class UTjfjxvg3 {
        public abstract UTjfjxvg3 show();
    }
    
    public  class UTmmag extends UTjfjxvg3 {
        @Override
        public UTmmag show() {
            return null;
        }
    }
    ```

    

## 抽象类与接口

> **抽象类通常是作为子类的基类，`描述的是子类共有的属性和行为，但某些行为需要子类去实现`；接口通常是描述一组类共同遵循的某种行为规范，`但它们本身可能不存在继承关系`**

* 成员变量：抽象类可以有任何修饰符的变量；接口必须且默认是public static final的常量，且定义时必须初始化
* 成员方法：抽象类有抽象方法和普通方法，抽象方法不能用private、static、final修饰；接口默认抽象方法，Java8后可以有默认方法、静态方法、私有方法
* 构造方法：抽象类可以有构造方法；接口不允许
* 实例化：两者都不能被实例化
* 继承关系：抽象类单继承；接口多实现
* **选择性：抽象类可以作为模版方法，定义了类的骨架；接口更倾向于添加新功能或兼容性问题，不适合作为骨架**





# IO流

> **所有数据读写操作在Java中都抽象为流，输入流：从数据源读取到程序中(内存中)；输出流：把数据从程序(内存)写出到目标**

* 字节流：以1个字节为单位传输数据，适合处理二进制数据，如图片、音视频
* 字符流：以字符(16位Unicode)为单位传输数据，适合处理文本数据





## 为什么需要缓冲流

* 不管是字节流还是字符流，每次读写时，都会直接和底层设备（文件、磁盘、网络）交互，但是磁盘和网络IO非常慢，如果一次只读写几个字节就会频繁调用，性能很差
  * eg：读取8192个字符，字符流需要8192次，缓冲流假设为1024的大小，需要8次
* **缓冲流在内存中维护了一个缓冲区（byte[ ] ）**
  * **读操作：一次性从底层设备读取一大块数据放到缓冲区，再从缓冲区返回给用户程序，避免了程序的磁盘读取。**
  * **写操作：先将数据写入到缓冲区，等缓冲区满了或手动flush()时，再一次性写入到底层设备，减少了系统调用次数**

> 在处理字符数据时，**BufferedReader**通常比**BufferedInputStream**更快，因为它专为字符流优化，减少了不必要的数据转换开销；在处理字节数据时，BufferedInputStream更为合适和高效。





## IO模型

* BIO（Blocking IO，阻塞IO）：读取或写入数据时，线程会一直等待（eg：Java的传统IO操作），直到数据准备就绪或写入完成，但在高并发下存在性能问题（因为线程会等待IO操作时阻塞，无法执行其它任务）
* NIO（Non- Blocking IO，非阻塞IO）：线程执行一个IO时不会一直等待，而是继续执行其它任务，需要通过轮询或者回调函数等机制检查IO操作是否完成，能更好的支持并发，但会导致CPU资源浪费（因为会不停的调用判断数据处理好了没）
* AIO（Asynchronous IO，异步IO）：线程执行IO时允许执行其它任务，不需要等待IO操作完成，操作系统完成后会自动通过回调通知，不需要轮询
* IO多路复用：使用操作系统Selector机制（eg：Java的Selector类），通过选择器，一个线程可以监听多个通道上的IO事件，从而在单线程中处理多个连接（socket）



## 序列化与反序列化

* 序列化：把Java对象转为字节的过程，这些字节序列可以保存在磁盘上、网络中传输，并允许程序将这些字节序列再次恢复成原来的对象
* 反序列化：把字节序列还原成 Java 对象的过程



注意：

1. 其中需要序列化的对象需要实现Serializable接口
2. `transient` 修饰的字段不会被序列化
3. **`serialVersionUID` 很重要**，类修改后如果 ID 不匹配，反序列化会失败
   * 如果该对象类没有指定默认的版本号，JVM会根据类结构自动生成版本号，当类的结构改变时，版本号也会变化，当旧的序列化数据反序列化时会报错，因为两者的版本号已经变化
   * 如果该对象类指定了默认的版本号，那么旧的序列化数据反序列化时，会认为版本兼容，新增字段在旧序列化数据会变成对应类型的默认值































































